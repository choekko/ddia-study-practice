# 09. 일관성과 합의

## 배경
### 목표
- 내결함성을 지닌 분산 시스템을 구축하는 데 쓰이는 알고리즘과 프로토콜의 몇 가지 예를 학습하기

### 선행 학습 필요 지식
| 용어 | 설명 |
| - | - |
|일관성|어플리케이션이 정의한 불변식을 지키도록 하는 성질|
|최종적 일관성| 모든 복제본이 결국은 같은 값으로 수렴하는 성질|
|compare-and-set 연산| 변수의 현재 값이 기대한 값과 같을 때만 새로운 값으로 원자적으로 교체하는, 락 없이 동시성을 제어할 수 있는 기법|

## 선형성(Linearizability)
### 의미
- 단일 객체에 대한 모든 읽기·쓰기가 실시간 한 지점에서 일어난 것처럼 보이는 성질
- 데이터 복사본이 하나만 있다는 환상을 만들어줄 수 있는 성질
- '최신성 보장'

### 선형성과 직렬성
- 직렬성
  - 트랜잭션들이 어떤 순서에 따라 실행되는 것처럼 동작되도록 보장하는 것
  - 인과성을 보장하지 않음
      ```
      초기: x = 0
    
      t1:  T1: write x := 1    
      t2:  T2: read x → 0 
      ```
- 선형성
  - 개별 객체에 실행되는 읽기와 쓰기에 대한 최신성 보장
    ```
    t1:  T1: CAS(y, 0, 0)   // 체크 용도: 읽기와 동일한 효과 (성공 → y가 0임을 관찰)
    t2:  T2: CAS(x, 0, 0)   // 체크 용도: x가 0임을 관찰
    t3:  T1: CAS(x, 0, 1)   // 성공 → x := 1
    t4:  T2: CAS(y, 0, 1)   // 성공 → y := 1
    ```
    - 객체 x, 객체 y 각각 봤을 때 최신성 만족됨 
    - 트랜잭션 직렬성이 보장되지 않아, 다중 객체 불변식을 만족하지 못할 수 있음 (x + y <= 1)
- 직렬성 + 선형성
  - = 엄격한 직렬성 or 강한 단일 복사본 직렬성
  - 2PL 은 엄격한 직렬성을 지님
  - SSI 는 선형성을 지니지 않음 (스냅숏에서 읽으면 최신성 보장 X)

### 선형성이 필요한 환경
1. 잠금과 리더 선출
   - 단일 리더 복제 시스템에서 스플릿 브레인이 일어나지 않도록 리더 선출이 필요
   - 리더 선출 방법 중 하나는 잠금을 사용해야하며, 이 잠금은 선형적이어야 함 (모든 노드는 어느 노드가 잠금을 소유하는지에 동의해야 함)

2. 제약 조건과 유일성 보장
   - 사용자명/이메일 중복 금지, 주문번호/티켓번호 유일, 재고 수량이 음수가 되면 안 되는 상황 등 엄격한 유일성 제약 조건이 필요한 상황은 선형성이 필요
   
3. 채널 간 타이밍 의존성
   - 별도 채널(예: DB 쓰기, 이메일/SMS 발송, 서드파티 콜백 등)로 같은 비즈니스 이벤트가 퍼질 때 선형성이 필요

### 선형성 시스템 구현
- 5장에서 설명된 복제 방법들은 선형성을 보장하는가?

| 복제 유형 | 선형성 여부 | 이유                                                         |
| - |--------|------------------------------------------------------------|
| 단일 리더 복제 | 가능성 있음  | 리더나 동기식으로 갱신된 팔로워에서 실행한 읽기는 선형성이 될 가능성이 있음                 | 
| 합의 알고리즘 | 선형적 | 성공 응답은 정족수에 반영된 후에만 반환하는 규칙을 둬서 선형성 보장                     |
| 다중 리더 복제 | 비선형적 | 여러 노드에서 동시에 쓰기를 처리하고 그렇게 쓰여진 내용을 비동기로 다른 노드에 복제하므로         |
| 리더 없는 복제 | 아마도 비선형적 | 느슨한 정족수는 선형성의 가능성을 망침 <br/> 엄격한 정족수를 사용해도 비선형적으로 동작할 가능성 있음 |


### 선형성의 트레이드 오프
- 선형성이 요구되고, 일부 복제 서버가 다른 복제 서버와 끊기면 일부 복제 서버는 연결이 끊긴 동안 요청 처리 불가 (어떤 방법을 쓰든 가용성 없음)
- 선형성이 요구되지 않고, 각 복제 서버가 다른 복제 서버와 연결이 끊기더라도 독립적으로 요청을 처리하는 방식으로 쓰기를 처리할 수 있음
  - 이 경우, 애플리케이션은 네트워크 문제에 직면해도 가용한 상태를 유지하지만 선형적이지 않음
- CAP (Consistency, Availability, Partition tolerance)
  - 때때로 세 개 중 두 개를 고르라고 표현되지만, 오해의 소지가 있음
  - 네트워크가 올바르게 동작할 때는, 일관성과 가용성 모두 제공 가능 
  - 네트워크 분단이 생겼을 때는 일관성과 가용성 중 하나를 선택해야하는 것

## 순서화 보장
### 인과성
- 시스템이 일과성에 의해 부과된 순서를 지키면 그 시스템은 '인과적으로 일관적' 이라고 함
- 예를 들어 SI 는 인과적 일관성을 제공

### 인과적 순서가 전체 순서는 아니다
- 전체 순서(total order)
  - 어떤 두 요소를 비교할 수 있게 하는 순서
  - 두 요소가 있으면 항상 어떤 것이 더 크고 어떤 것이 더 작은지 말할 수 있음
- 부분 순서(partially order)
  - 어떤 두 요소의 부분적 순서
  - 수학의 '집합'은 전체 순서를 정할 수 없기에, '비교 불가'하고 '부분적으로 순서가 정해진다'고 함
- 선형성과 인과성에서의 전체 순서
  - 선형성
    - 선형성 시스템은 데이터 복사본이 하나만 있는 것처럼 동작하므로, 모든 연산이 원자적이면 전체 순서를 정할 수 있음
  - 인과성
    - 두 이벤트에 인과적인 관계가 있으면 이들은 순서가 있지만, 동시에 실행되면 비교할 수 없으므로 부분적으로 순서가 정해짐

### 선형성은 인과적 일관성보다 강하다
- 선형성은 인과성을 내포
  - 즉, 시스템이 선형적이라면 인과성도 올바르게 유지
- 선형성은 인과성을 보존하는 유일한 방법은 아님
- 선형성이 필요한 것처럼 보이는 대부분의 시스템에 사실 필요한 것은 인과적 일관성 

### 비선형적 시스템이 인과적 일관성을 유지하는 방법
- 인과적 순서를 결정하기 위해 데이터베이스는 애플리케이션이 데이터의 어떤 버전을 읽었는지 알아야 함
- ex) 버전벡터, SSI
- 인과적 의존성은 단일 키 뿐만 아니라 전체 데이스베이스에 걸친 인과적 의존성을 추적해야 함
  - 모든 인과적 의존성을 실제로 추적하는 것은 실용성이 떨어짐 -> 일련번호 순서화로 대응

### 일련번호 순서화
- 일련번호나 타임스탬프를 써서 이벤트의 순서를 정할 수 있음
  - 타임스탬프는 일 기준 시계 말고 논리적 시계에서 얻어도 됨
- 단일 리더 복제의 리더는 연산마다 카운터를 증가시켜 복제 로그의 각 연산에 단조 증가하는 일련번호를 할당하기만 하면 됨
- 단일 리더가 아닌 복제의 경우, 일련번호를 생성하는 일부 방식들은 인과성에 인과적이지 않음

### 램포트 타임 스탬프
- 각 노드는 고유 식별자를 갖고, 각 노드는 처리한 연산 개수를 카운터로 유지하여 (카운터, 노드 ID)쌍으로 구성한 타임스탬프
- 모든 노드와 모든 클라이언트가 지금까지 본 카운터 값 중 최댓값을 추적하고 모든 요청에 그 최댓값을 포함시키면서 진행
  - 노드가 자신의 카운터 값보다 큰 최대 카운터를 가진 요청이나 응답을 받으면 바로 자신의 카운터를 그 최댓값으로 증가시킴 
- 한계
  - 다른 어떤 노드도 동시에 더 낮은 타임 스탬프를 가지고 동일한 내용의 트랜잭션을 처리하는 중이 아니라고 확신하려면 다른 모든 노드가 무엇을 하고 있는지 확인 필요
  - 이에 따라 분산 시스템의 여러 공통 문제를 해결하는데 아주 충분하지는 않음 

## 전체 순서 브로드 캐스트
- 전체 순서 브로드 캐스트: 모든 메시지를 모든 노드가 같은 순서로 받도록 보장하는 통신
- 비공식적인 전제 조건
  - 신뢰성 있는 전달
    - 어떤 메시지도 손실되지 않음
    - 메시지가 한 노드에 전달되면 모든 노드에도 전달됨
  - 전체 순서가 정해진 전달
    - 메시지는 모든 노드에 같은 순서로 전달

### 전체 순서 브로드캐스트와 선형성의 차이
- 전체 순서 브로드캐스트는 비동기식
  - 메시지는 고정된 순서로 신뢰성 있게 전달되도록 보장되지만, 언제 전달될지는 보장하지 않음
- 선형성은 최신성 보장

> 분산 트랜잭션과 합의
> 
## 원자적 커밋과 2단계 커밋
### 배경
- 트랜잭션에 여러 노드가 관여하게 되는 경우, 어떤 노드에서는 커밋이 성공하고, 다른 노드에서는 실패해서 원자성 보장을 위반하기 쉬움

### 2PC
- 2PC는 '코디네이터'를 사용
- 과정
  0. 애플리케이션이 커밋할 준비가 되면 코디네이터가 1단계를 시작
  1. (1단계) 각 노드에 준비 요청을 보내서 커밋할 수 있는지 물어보고 응답을 대기
     - 모든 참여자(노드)의 응답을 받으면 (2단계) 진행
  2. (2단계) 모든 참여자가 "네"로 응답했다면 모든 참여자에게 커밋 요청을 보내고, 만약 누구라도 "아니오"로 응답하면 모든 참여자에 어보트 요청을 보냄
- 과정 중 참여자 장애에 따른 반응
  - 1단계 요청 중 장애 시, 모든 참여자에게 어보트 요청이 성공할 때까지 재시도
  - 2단계 요청 중 장애 시, 전송된 커밋이나 어보트 요청이 성공할 때까지 재시도
- 코디네이터 장애에 따른 반응
  - 1단계 요청에 참여자가 응답한 이후 코디네이터 장애 시, 참여자는 커밋 결과를 회신 받을 때까지 대기
  - 이 상태에 있는 참여자를 '의심스럽다' 또는 '불확실하다'고 함 -> 잠금 처리에 문제가 생길 수 있음
  - 관리자가 수동으로 처리해야 함 (후술할 XA의 구현체에는 경험적 결정이라는 비상탈출구를 제공하기도 함)
- 3PC
  - 2PC는 코디네이터가 복구하기를 기다리느라 멈출 수 있다는 사실 때문에 블로킹 원자적 커밋 프로토콜이라고 불림
  - 이론적으로, 완벽한 장애 감지기를 활용한 3PC 알고리즘으로 논블로킹한 프로토콜을 만들 수 있음

### XA 트랜잭션
- X/Open XA
  - 이종 기술에 걸친 2PC를 구현하는 표준
  - 트랜잭션 코디네이터와 연결되는 인터페이스를 제공하는 C API

## 내결함성을 지닌 합의 
- 합의 알고리즘이 만족해야하는 속성

  | 속성     |설명|
  |--------|-|
   | 균일한 동의 |어떤 두 노드도 다르게 결정하지 않는다 |
    | 무결성    | 어떤 노드도 두번 결정하지 않는다 |
    | 유효성    | 한 노드가 값 v를 결정한다면 v는 어떤 노드에서 제안된 것이다
    | 종료 | 죽지 않는 모든 노드는 결국 어떤 값을 결정한다|
- 균일한 동의, 무결성, 유효성은 안전성 속성이라고도 함 

### 합의 알고리즘과 전체 순서 브로드 캐스트
- 내결함성을 지닌 합의 알고리즘 중 널리 알려진 것들은, 값의 순차열에 대해 결정해서 전체 순서 브로드 캐스트 알고리즘을 만듬
  - 전체 순서 브로드캐스트를 하려면 모든 노드에게 메시지가 정확히 한 번, 같은 순서로 전달되어야 함
  - 각 회마다 노드들은 다음에 보내기 원하는 메시지를 제안하고 전체 순서 상에서 전달될 다음 메시지를 결정
  - 즉, 전체 순서 브로드캐스트는 합의를 여러 번 반복하는 것과 동일

### 단일 리더 복제와 합의
- 단일 리더 복제는 본질적으로 전체 순서 브로드캐스트와 비슷하지만, 리더 선출이 수동으로 정해진다면 '합의'가 필요 없어짐
- 만약 전체 순서 브로드캐스트를 이용한 합의 알고리즘을 사용해 자동 리더 선출을 하는 경우, 다음과 같은 난제 발생
  1. 스플릿 브레인 문제 발생
  2. 리더 선출을 위해 합의 필요
  3. 그런데 합의 알고리즘이 전체 순서 브로드캐스트를 사용
  4. 전체 순서 브로드 캐스트는 리더가 필요 -> 2번으로 감
- 해결 방법: 에포크 번호 붙이기
  - 현재 리더가 죽었다고 생각될 때마다 새 리더를 선출하기 위해 노드 사이에서 투표가 시작될 때, 에포크 번호를 붙여 투표하고, 두 가지 다른 에포크에 있는 두 가지 다른 리더 사이에 충돌이 있으면 에포크 번호가 높은 리더가 이기는 방식을 사용
  - 이 방식으로 정족수에 맞게 선출된 리더를 실제 리더로 선출

### 합의의 제약
- 제안이 결정되기 전에 노드가 제안에 투표하는 과정은 일종의 동기식 복제 -> 성능 떨어짐
- 합의 시스템은 항상 엄격한 과반수도 동작하기를 요구하므로, 최소한 세 대의 노드가 필요
- 대부분의 합의 알고리즘(정적 멤버십 알고리즘)은 노드 집합이 고정되어 있다고 가정하므로, 클러스터에 노드를 근야 추가하거나 제거할 수 없음
  - 동적 멤버십 확장은 노드 추가를 허용하지만, 정적 멤버십 알고리즘보다 훨씬 이해하기 어려움
- 합의 시스템은 장애 노드 감지를 타임 아웃에 의존하는데, 네트워크 지연의 변동이 심한 경우, 잦은 리더 선출로 성능 떨어질 수 있음


# 데모
## 2PC
```shell
rm -rf _2pc_logs
python -m two_phase_commit.demo
```
- 2pc 시스템에서 정상 상황, 1단계에서 참여자가 거부하는 상황, 1단계 응답 이후 참여자 하나가 죽은 상황을 데모
- '_2pc_logs' 폴더에 코디네이터와 참여자의 진행 기록이 담기고, 이를 활용함 