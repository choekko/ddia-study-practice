# 트랜잭션 (Transactions)

트랜잭션은 동시성과 장애 속에서도 \*\*데이터 불변식(invariants)\*\*을 지키기 위한 추상화 

---

## 1) ACID (트랜잭션이 제공하는 안전성 보장)

* **원자성(Atomicity)**: 트랜잭션 내부 작업은 전부 반영되거나 전혀 반영되지 않음. 중간상태 노출 없음.
* **지속성(Consistency)**: 커밋된 결과는 장애 후에도 살아남도록 로그/복구 메커니즘으로 보장.
* **격리성(Durability)**: 동시에 실행돼도 결과가 마치 순차적으로 실행된 것처럼 보이게 한다 (얼마나 ‘그럴듯’하게 보이게 할지는 격리 수준에 따라 다름).
* **일관성(Consistency)**: DB가 보장한다기보다 **어플리케이션이 정의한 불변식**을 지키도록 원자성과 격리성이 ‘도와주는’ 개념에 가까움

---

## 2) 완화된 격리 수준 

### Read Committed (커밋 후 읽기)

- 커밋 후 읽기는 다음이 발생하지 않도록 보장함
  - **Dirty Read**: 커밋 전 데이터를 읽어버리는 현상. 
  - **Dirty Write**: 커밋 전 값을 덮어쓰는 것
- 커밋 후 읽기는 다음이 발생하지 않도록 보장할 수 없음
  - **Read Skew(=Nonrepeatable Read)**: 같은 트랜잭션 안에서 같은 로우를 두 번 읽을 때 값이 달라짐. 

### Snapshot Isolation (SI, 스냅샷 격리)

* MVCC를 활용해 트랜잭션 시작 시점의 **일관된 스냅샷**을 읽음
  * MVCC(Multi-Version Concurrency Control): 한 객체/로우의 여러 버전을 유지해 읽기와 쓰기를 분리하는 방식.
* 스냅샷 격리는 **Read Skew**를 제거.
* 갱신 손실, 쓰기 스큐, 팬텀 현상을 막을 순 없음

---

## 3) 갱신 손실(Lost Update) — 원인과 해결

### 발생 형태

```text
T1: x를 읽어 10 → x := x + 1 준비
T2: x를 읽어 10 → x := x + 1 준비
T1 커밋 → x = 11
T2 커밋 → x = 11  (T1의 증가가 사라짐)
```

### 예방 기법

1. **원자적 쓰기 연산**
   - DB가 제공하는 **증가/감소**, **원자적 합치기**, **비트 연산**, **조건부 갱신** 같은 원자적 연산을 사용해 **읽기+쓰기**를 한 단계로 만든다.

2. **명시적 로킹(SELECT … FOR UPDATE)**
   - 읽을 때 **배타락**을 걸어, 동시 갱신을 직렬화한다.
    ```sql
    BEGIN;  

    SELECT * 
    FROM accounts
    WHERE id = 1
    FOR UPDATE;
    
    -- 이 시점에서 id=1 행은 다른 트랜잭션이 수정 못함
    
    UPDATE accounts
    SET balance = balance - 100
    WHERE id = 1;
    
    COMMIT;
    ```

   * 간단하고 확실하지만 경쟁이 높으면 대기/교착(데드락) 비용이 생길 수 있다.

3. **compare-and-set (CAS, 조건부 갱신)**
   “현재 값이 내가 예상한 값과 같을 때만 덮어써라”

   ```sql
   -- 의사코드
   UPDATE items
   SET value = :new
   WHERE id = :id AND value = :expected;
   -- 갱신된 행 수 = 1 이면 성공, 0 이면 경쟁 충돌 → 재시도
   ```

   * 단일 키/문서 업데이트에 강력하며, 재시도 루프와 함께 쓰면 갱신 손실을 안전하게 피한다.
   * 단, WHERE 절이 오래된 스냅샷으로부터 읽는 것을 허용하면, 이 방법으로 막지 못할 수 있음


---

## 4) 쓰기 스큐(Write Skew)와 팬텀(Phantom)

### 쓰기 스큐(Write Skew)

* 예시: **당직 의사 최소 1명** 불변식.
  - 두 트랜잭션이 “현재 당직 1명 있음”을 **같이 확인**하고 각자 자신의 당직을 취소 → 둘 다 커밋되면 **0명**이 된다.
* 공통 구조: **같은 조건을 읽고 서로 다른 행을 갱신**하기 때문에 직접적인 쓰기-쓰기 충돌이 없어 SI가 허용해버린다.

### 팬텀(Phantom)

* “`WHERE condition`을 만족하는 행이 존재하지 않는다”를 확인한 뒤, 다른 트랜잭션이 **그 조건을 만족하는 새 행을 삽입**해 불변식이 깨진다.
* 이처럼 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 '팬텀' 이라고 한다. '팬텀'이 쓰기 스큐를 유발한다. 
* 예: “회의실 예약 시간대에 겹치는 항목이 없어야 한다” → 동시 삽입이 서로를 보지 못하고 겹치는 레코드가 생성.

### 대처법

* \*\*직렬성(Serializable)\*\*을 갖춘다(2PL이나 SSI).
* 혹은 **서술 잠금/색인 범위 잠금**으로 **조건 자체에 락**을 건다.

* **충돌 구체화(Materializing Conflicts)**: 불변식을 **물리적 자원**(단일 로우/카운터/락 테이블)으로 **구체화**해 **같은 자원을 같이 쓰도록** 만들어 write-write 충돌로 전환한다.

  * 예: “특정 시간대·회의실” 조합에 대해 단일 키를 생성/잠궈버리는 설계.

---

## 5) 직렬성(Serializable)

### (a) 2PL(Strict Two-Phase Locking)

* 읽기에도 공유락, 쓰기에 배타락. **락을 모두 잡은 뒤에만 해제**한다.
* **팬텀 방지**: **서술 잠금**(조건 단위)이나 **색인 범위 잠금**으로 범위를 잠근다.
  * 서술 잠금(predicate lock): 어떤 조건(예: “나이 > 30인 모든 행”)에 해당하는 레코드 집합 전체를 보호하는 잠금
  * 색인 범위 잠금(index-range lock): 조건에 해당하는 인덱스 범위를 잠그는 방식
* 장점: 직관적이고 강력. 단점: **교착상태**와 **락 경합 비용**.

### (b) SSI(Serializable Snapshot Isolation)

* MVCC 기반 스냅샷을 쓰면서, 백그라운드에서 **위험한 의존 그래프**(rw-dependency cycles)를 **탐지해 한 트랜잭션을 중단**한다.
* 장점: 락 경합이 적고 읽기 성능이 좋다. 단점: **충돌 시 중단/재시도**가 애플리케이션에 보일 수 있다.
* PostgreSQL `SERIALIZABLE`이 대표적 구현.


## 8) 빠른 참조: 격리 수준 vs 이상 현상

| 격리 수준                   | Dirty Read | Dirty Write | Read Skew/Nonrepeatable | 갱신 손실 | 쓰기 스큐 | 팬텀    |
| ----------------------- | ---------- | ----------- | ----------------------- | ----- | ----- | ----- |
| Read Uncommitted        | 발생         | 발생          | 발생                      | 발생    | 발생    | 발생    |
| Read Committed          | 차단         | 차단          | 발생                      | 발생    | 발생    | 발생    |
| Snapshot Isolation (SI) | 차단         | 차단          | 차단                      | 발생 가능 | 발생 가능 | 발생 가능 |
| Serializable (2PL/SSI)  | 차단         | 차단          | 차단                      | 차단    | 차단    | 차단    |



## 데모
1. 관계형과 비관계형 모델에서의 트랜잭션 비교
```shell
python -m relational_vs_document.demo
```

2. SI, 2PL, SSI 비교해보기
```shell
python -m transaction.si_vs_2pl_vs_ssi.demo
```