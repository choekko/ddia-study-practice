# 12-2. 데이터베이스 언번들링

## 데이터 저장소 기술 구성하기
- 모든 접근 패턴에 적합한 단일 데이터 모델이나 저장 형식이 없을 경우, 서로 다른 저장소와 처리 도구를 사용하지만 하나의 응집된 시스템으로 구성할 수 있는 두 가지 길이 있다고 필자는 생각
  - 연합 데이터베이스: 읽기를 통합
    - 엄청나게 많은 하단 저장소 엔진과 처리 메서드를 통합해 질의하는 인터페이스를 제공
    - 특정 데이터 모델과 특정 질의 인터페이스가 필요한 경우, 여전히 하단 저장소에 직접 접근할 수 있지만, 사용자가 다른 장소의 데이터를 결합하기 원한다면 결합 인터페이스를 통해 쉽게 처리 가능
    - (어쩌면 Trino..?)
  - 언번들링 데이터베이스: 쓰기를 통합
    - 연합 데이터베이스는 여러 시스템에 걸친 쓰기를 동기화하기에는 적합하지 않은 해결 책
    - 저장소 시스템들을 신뢰성 있게 결합하기 쉽게 만드는 것은 데이터베이스의 색인 유지 기능을 다른 기술에 걸친 쓰기를 동기화할 수 있는 방식으로 '언번들링'하는 방식과 유사
    ```text
    [GPT say]
    
    1. 데이터베이스의 전통적 구조
        전통적 RDBMS는 내부에서 저장(데이터 파일) 과 색인 유지(인덱스 동기화) 를 한 묶음으로 처리합니다.
        즉, 어떤 행을 INSERT 하면, 디스크에 데이터를 쓰는 동시에, 그 행을 찾기 위한 인덱스(B-tree 등) 도 같은 트랜잭션 안에서 갱신되죠.
        이 덕분에 사용자는 “데이터와 색인이 항상 일치한다”는 신뢰성을 가집니다.
    2. 언번들링(Unbundling)의 아이디어
        DDIA는 이 묶음을 풀자(Unbundle) 라고 제안합니다.
        “색인 유지 기능”은 꼭 DB 안에만 있을 필요가 없고, 별도의 시스템에서 원본 로그를 보고 스스로 색인을 만들어 유지할 수 있다는 거예요.
        이렇게 하면 원본 저장소는 사실 기록에만 집중하고,
        색인/조회 최적화 저장소는 로그를 구독하며 자기 색인을 유지합니다.
    ```
    
### 언번들링이 동작하게 만들기
- 쓰기를 동기화하는 전통적인 접근법은 이종 저장소 시스템 간 분산 트랜잭션이 필요
  -> 하지만 데이터가 다른 기술 사이의 경계를 오간다면 멱등성을 기반으로 쓰기를 수행하는 비동기 이벤트 로그를 사용하는 편이 훨씬 더 강력하고 현실적인 접근법이라고 봄
- 로그 기반 통합의 큰 장점: 구성 요소간 느슨한 결합

### 언번들링의 목표
- 특정 작업부하에 대한 성능 측면에서 개별 데이터베이스와 경쟁하는 것이 아님
- 몇 개의 다른 데이터베이스를 결합해 단일 소프트웨어로 가능한 것보다 더 넓은 범위의 작업 부하에 대해 좋은 성능을 달성하기 위함 (깊이보다 폭)

## 데이터플로-like 애플리케이션 설계
- 언번들링 데이터베이스 접근법은 데이터 플로, 함수형 반응형 프로그래밍 등의 아이디어를 합친 것
- 스프레드시트조차 대부분의 주류 프로그래밍 언어보다 수 마일 앞선 데이터플로 프로그래밍 능력을 보유
  - 한 셀에 수식을 넣으면 수식의 입력이 바뀔 때마다 수식 결과가 자동으로 재계산됨 -> 데이터 시스템 수준에서도 필요한 기능

### 데이터플로: 상태 변경과 애플리케이션 코드 간 상호작용
- 데이터플로 측면에서 애플리케이션을 생각한다는 것은 애플리케이션 코드와 상태 관리 간의 관계를 재조정한다는 의미
  - 전형적인 웹 애플리케이션의 모델에서 데이터베이스는 네트워크를 통해 동기식으로 접근할 수 있는 변경 가능한 공유 변수와 같이 동작
  - 대부분의 프로그래밍 언어에서 변경 가능한 변수의 변경을 구독할 수 없음
- 데이터베이스를 애플리케이션이 직접 조작하는 수동적 변수로 취급하는 대신, 상태와 상태 변경, 그리고 상태를 처리하는 코드 간의 상호작용과 협동에 관해 좀 더 생각해볼 수 있음
  - 즉, 애플리케이션 코드는 어떤 곳에서 상태 변화를 트리거해 다른 곳의 상태 변화에 응답함
- 데이터베이스를 언번들링한다는 의미는 '데이터베이스의 변경 로그를 구독 가능한 이벤트 스트림으로 취급하는 아이디어'를 원본 데이터베이스 외부에 파생 데이터셋을 생성할 때 적용한다는 뜻

### 마이크로 서비스 접근법과 데이터플로 접근법
- 스트림 연산자로 데이터플로 시스템을 구성하는 것은 마이크로 서비스 접근법과 유사한 특징이 많지만, 기반이 되는 통신 매커니즘은 매우 다름 
  - 마이크로서비스 접근법: 동기식 요청/응답 상호작용 사용
  - 스트림 연산자로 구성한 시스템: 단방향 비동기식 메시지 스트림 사용
- "한 소비자가 특정 통화로 가격이 매겨진 상품을 구매했지만, 지불은 다른 통화로 했다고 가정"
  - 마이크로서비스 접근법
    - 구매 처리 코드는 아마도 특정 통화의 현재 활율을 얻기 위해 환율 서비스나 데이터베이스에 질의
  - 데이터플로 접근법
    - 구매 처리 코드는 미리 환율 갱신 스트림을 구독하고 환율이 바뀔 때마다 로컬 데이터베이스에 환율을 기록
    - 구매 처리가 들어올 때 단지 로컬 데이터베이스에 질의
- 데이터플로 접근법은 훨씬 빠를 뿐 아니라 다른 서비스 장애에도 훨씬 잘 버틸 수 있음
- 가장 빠르고 가장 신뢰성 있는 네트워크 요청은 네트워크 요청을 전혀 하지 않는 것

## 파생 상태 관찰하기
- 데이터플로 시스템은 검색 색인이나 구체화 뷰, 또는 예측 모델과 같은 파생 데이터셋을 생성하고 최신 상태로 유지하는 과정에 사용 가능 -> 이 과정을 '쓰기 경로' 라 가정
- 파생 데이터셋을 생성하는 이유는, 다시 질의할 가능성이 크기 때문 -> 그 질의 경로를 '읽기 경로' 라 가정
- 쓰기 경로 예시
  - 문서 갱신 -> (애플리케이션 서버) -> (언어 분석) -> (검색 색인)
- 읽기 경로 예시
  - 검색 질의 -> (애플리케이션 서버) -> (색인 질의 실행기) -> (검색 색인)
- 파생 데이터셋은 쓰기 경로와 읽기 경로가 만나는 장소 (위 예시에서는 검색 색인)

### 오프라인 대응 가능한 상태 저장 클라이언트
- 전통적으로 웹 브라우저는 상태 비저장 클라이언트로 인터넷 연결이 됐을 때만 유용한 일을 할 수 있음 -> 오프라인 우선 애플리케이션에 관심을 불러 일으킴
- 상태 비저장 클라이언트가 항상 중앙 서버와 통신한다는 가정에서 벗어나 최종 사용자 장치에서 상태를 유지하는 쪽으로 나아가면 새로운 기회가 있는 세상이 열림
  - 이는, 쓰기 경로에서 더 많은 일을 하여 읽기 경로의 작업을 줄이는 것

### 상태 변경을 클라이언트에게 푸시하기
- 많은 최신 프로토콜이 HTTP의 기본적인 요청/응답 패턴을 벗어나고 있음
  - ex) 서버 전송 이벤트, 웹소켓
- 쓰기 경로와 읽기 경로 모델 측면에서 상태 변화를 적극적으로 클라이언트 장치에까지 푸시하면 쓰기 경로가 최종 사용자까지 확장됨
- 상태 비저장 클라이언트와 요청/응답 방식의 상호작용이 데이터베이스, 라이브러리, 프레임워크, 프로토콜에 뿌리 깊게 배어있기 때문에 쓰기 경로를 최종 사용자까지 확장하려면 근본적으로 시스템을 구축하는 방식을 재고할 필요성이 있음


## 두 줄 정리
```text
1. 데이터베이스 언번들링은 단일 DB가 다 해주던 색인/질의 기능을 외부 파생 시스템으로 확장해, 로그 기반 동기화를 통해 여러 저장소를 신뢰성 있게 결합할 수 있게 한다.
2. 이를 통해 빠른 처리, 내결함성, 느슨한 결합성을 가진 미래지향적 데이터 시스템을 구현할 수 있다.
```

## 실습
- PostgresQL FDW (Foreign Data Wrapper)
```shell
cd future
docker compose up -d
pip install pymongo
python fdw_demo.py
```